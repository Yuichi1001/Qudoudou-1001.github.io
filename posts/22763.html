<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2023年国科大杨力祥《高级操作系统》期末思考题汇总 | Yuichi's Blog</title><meta name="author" content="Yuichi"><meta name="copyright" content="Yuichi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.为什么开始启动计算机的时候，执行的是BIOS代码而不是操作系统自身的代码？因为刚开始启动计算机的时候，计算机的内存还没有初始化。由于CPU只能执行内存中的代码，因此需要把操作系统从软盘或硬盘中加载到内存上。这就需要硬件主动加载BIOS程序，由BIOS准备好中断向量表和中断服务程序，接着通过中断将引导程序bootsect加载到内存里。再通过后续的一系列执行，操作系统的代码才能位于内存中，供CPU">
<meta property="og:type" content="article">
<meta property="og:title" content="2023年国科大杨力祥《高级操作系统》期末思考题汇总">
<meta property="og:url" content="https://yuichi.top/posts/22763.html">
<meta property="og:site_name" content="Yuichi&#39;s Blog">
<meta property="og:description" content="1.为什么开始启动计算机的时候，执行的是BIOS代码而不是操作系统自身的代码？因为刚开始启动计算机的时候，计算机的内存还没有初始化。由于CPU只能执行内存中的代码，因此需要把操作系统从软盘或硬盘中加载到内存上。这就需要硬件主动加载BIOS程序，由BIOS准备好中断向量表和中断服务程序，接着通过中断将引导程序bootsect加载到内存里。再通过后续的一系列执行，操作系统的代码才能位于内存中，供CPU">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuichi.top/img/cover/15.jpg">
<meta property="article:published_time" content="2023-12-21T08:32:27.000Z">
<meta property="article:modified_time" content="2024-04-12T02:11:59.172Z">
<meta property="article:author" content="Yuichi">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuichi.top/img/cover/15.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yuichi.top/posts/22763.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2023年国科大杨力祥《高级操作系统》期末思考题汇总',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-12 10:11:59'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 1
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/myStyle.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Yuichi's Blog"><span class="site-name">Yuichi's Blog</span></a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">2023年国科大杨力祥《高级操作系统》期末思考题汇总</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-21T08:32:27.000Z" title="发表于 2023-12-21 16:32:27">2023-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-12T02:11:59.172Z" title="更新于 2024-04-12 10:11:59">2024-04-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2023年国科大杨力祥《高级操作系统》期末思考题汇总"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="1-为什么开始启动计算机的时候，执行的是BIOS代码而不是操作系统自身的代码？"><a href="#1-为什么开始启动计算机的时候，执行的是BIOS代码而不是操作系统自身的代码？" class="headerlink" title="1.为什么开始启动计算机的时候，执行的是BIOS代码而不是操作系统自身的代码？"></a>1.为什么开始启动计算机的时候，执行的是BIOS代码而不是操作系统自身的代码？</h3><p>因为刚开始启动计算机的时候，计算机的内存还没有初始化。由于CPU只能执行内存中的代码，因此需要把操作系统从软盘或硬盘中加载到内存上。这就需要硬件主动加载BIOS程序，由BIOS准备好中断向量表和中断服务程序，接着通过中断将引导程序bootsect加载到内存里。再通过后续的一系列执行，操作系统的代码才能位于内存中，供CPU执行。</p>
<h3 id="2-为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有直接把所有需要加载的扇区都加载？"><a href="#2-为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有直接把所有需要加载的扇区都加载？" class="headerlink" title="2.为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有直接把所有需要加载的扇区都加载？"></a>2.为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有直接把所有需要加载的扇区都加载？</h3><p>因为操作系统和BIOS通常是由不同的团队进行开发的。为了能够协调工作，双方按照固定的约定进行代码的开发。对于BIOS来说，它接收到启动命令后就将启动扇区的代码加载至0x07c00（BOOTSEG）处，至于启动扇区里的内容是什么，BIOS一概不管。而后续的代码则由操作系统自己的bootsect代码进行加载，这些代码由编写操作系统的团队负责。这样构建可以让BIOS和操作系统的设计团队按照自己的意愿进行代码设计，使内存规划更加灵活。如果BIOS直接把所有需要加载的扇区一次性进行加载，可能会出现以下问题：①不同的操作系统代码长度不一样，由BIOS进行操作系统的加载可能会导致系统加载不完全②如果使用BIOS进行加载，等待系统加载完毕后再执行，则需要等待较长的时间，因此Linux采用的就是边加载边执行的方法</p>
<h3 id="3-为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？"><a href="#3-为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？" class="headerlink" title="3.为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？"></a>3.为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？</h3><p>有以下几个原因：</p>
<p>①BIOS在0x00000开始的位置构建起了中断向量表，暂时不能被覆盖，因此不能把bootsect加载到0x00000位置</p>
<p>②bootsect运行时产生的数据有些需要进行保存以供后续使用，而之后拷贝内核system时会将0x07c00处覆盖，造成数据的丢失，因此需要将该bootsect挪到0x90000处</p>
<p>③加载到0x07c00位置是历史约定，不是bootsect能够决定的，因此只能由bootsect在运行时把自己拷贝到0x90000处</p>
<h3 id="4-bootsect、setup、head程序之间是怎么衔接的？给出代码证据。"><a href="#4-bootsect、setup、head程序之间是怎么衔接的？给出代码证据。" class="headerlink" title="4.bootsect、setup、head程序之间是怎么衔接的？给出代码证据。"></a>4.bootsect、setup、head程序之间是怎么衔接的？给出代码证据。</h3><p>①bootsect将setup加载到0x90200处</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">INITSEG  <span class="token operator">=</span> <span class="token number">0x9000</span>			<span class="token operator">!</span> we move boot here <span class="token operator">-</span> out of the way

	jmpi	go<span class="token punctuation">,</span>INITSEG	<span class="token operator">!</span> 修改 cs
go<span class="token operator">:</span>	mov	ax<span class="token punctuation">,</span>cs
	mov	ds<span class="token punctuation">,</span>ax
	mov	es<span class="token punctuation">,</span>ax

load_setup<span class="token operator">:</span>
	mov	dx<span class="token punctuation">,</span>#<span class="token number">0x0000</span>		<span class="token operator">!</span> drive <span class="token number">0</span><span class="token punctuation">,</span> head <span class="token number">0</span>
	mov	cx<span class="token punctuation">,</span>#<span class="token number">0x0002</span>		<span class="token operator">!</span> sector <span class="token number">2</span><span class="token punctuation">,</span> track <span class="token number">0</span>
	mov	bx<span class="token punctuation">,</span>#<span class="token number">0x0200</span>		<span class="token operator">!</span> address <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">,</span> in INITSEG
	mov	ax<span class="token punctuation">,</span>#<span class="token number">0x0200</span><span class="token operator">+</span>SETUPLEN	<span class="token operator">!</span> service <span class="token number">2</span><span class="token punctuation">,</span> nr of sectors
	<span class="token keyword">int</span>	<span class="token number">0x13</span>			<span class="token operator">!</span> read it
	jnc	ok_load_setup		<span class="token operator">!</span> ok <span class="token operator">-</span> <span class="token keyword">continue</span>
	mov	dx<span class="token punctuation">,</span>#<span class="token number">0x0000</span>
	mov	ax<span class="token punctuation">,</span>#<span class="token number">0x0000</span>		<span class="token operator">!</span> reset the diskette
	<span class="token keyword">int</span>	<span class="token number">0x13</span>
	j	load_setup
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>②bootsect将system加载到0x10000处</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">SYSSIZE <span class="token operator">=</span> <span class="token number">0x3000</span>
SYSSEG   <span class="token operator">=</span> <span class="token number">0x1000</span>			<span class="token operator">!</span> system loaded at <span class="token number">0x10000</span> <span class="token punctuation">(</span><span class="token number">65536</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
ENDSEG   <span class="token operator">=</span> SYSSEG <span class="token operator">+</span> SYSSIZE		<span class="token operator">!</span> where to stop loading

	mov	ax<span class="token punctuation">,</span>#SYSSEG
	mov	es<span class="token punctuation">,</span>ax		<span class="token operator">!</span> segment of <span class="token number">0x010000</span>
	call	read_it

read_it<span class="token operator">:</span>
	mov ax<span class="token punctuation">,</span>es
	test ax<span class="token punctuation">,</span>#<span class="token number">0x0fff</span>		<span class="token operator">!</span> <span class="token number">64</span>KB 对齐
die<span class="token operator">:</span>	jne die			<span class="token operator">!</span> es must be at <span class="token number">64</span>kB boundary
	xor bx<span class="token punctuation">,</span>bx		<span class="token operator">!</span> bx is starting address within segment
rp_read<span class="token operator">:</span>
	mov ax<span class="token punctuation">,</span>es
	cmp ax<span class="token punctuation">,</span>#ENDSEG		<span class="token operator">!</span> have we loaded all yet<span class="token operator">?</span>
	jb ok1_read
	ret
ok1_read<span class="token operator">:</span>
	seg cs
	mov ax<span class="token punctuation">,</span>sectors		<span class="token operator">!</span> 每磁道扇区数
	sub ax<span class="token punctuation">,</span>sread		<span class="token operator">!</span> 当前磁道已读扇区数
	mov cx<span class="token punctuation">,</span>ax
	shl cx<span class="token punctuation">,</span>#<span class="token number">9</span>			<span class="token operator">!</span> 计算一共有多少个字节 <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">512</span><span class="token punctuation">)</span> 以下是用来判断是否超过 <span class="token number">64</span>KB，真正有用的是 ax
	add cx<span class="token punctuation">,</span>bx			<span class="token operator">!</span> 段内当前偏移值
	jnc ok2_read
	je ok2_read			<span class="token operator">!</span> 没有超过 <span class="token number">64</span>KB
	xor ax<span class="token punctuation">,</span>ax
	sub ax<span class="token punctuation">,</span>bx			<span class="token operator">!</span> 计算此时最多能读入的字节数
	shr ax<span class="token punctuation">,</span>#<span class="token number">9</span>
ok2_read<span class="token operator">:</span>
	call read_track
	mov cx<span class="token punctuation">,</span>ax			<span class="token operator">!</span> 该次操作读取的扇区数
	add ax<span class="token punctuation">,</span>sread		<span class="token operator">!</span> 当前磁道已读扇区数
	seg cs
	cmp ax<span class="token punctuation">,</span>sectors		
	jne ok3_read		<span class="token operator">!</span> 如果当前磁道还有扇区未读，则跳转到 ok3_read
	mov ax<span class="token punctuation">,</span>#<span class="token number">1</span>
	sub ax<span class="token punctuation">,</span>head
	jne ok4_read		<span class="token operator">!</span> 如果是 <span class="token number">0</span> 磁头，则去读 <span class="token number">1</span> 磁头面上的扇区数据
	inc track			<span class="token operator">!</span> 否则去读下一磁道
ok4_read<span class="token operator">:</span>
	mov head<span class="token punctuation">,</span>ax
	xor ax<span class="token punctuation">,</span>ax			<span class="token operator">!</span> 清零当前已读扇区数
ok3_read<span class="token operator">:</span>
	mov sread<span class="token punctuation">,</span>ax
	shl cx<span class="token punctuation">,</span>#<span class="token number">9</span>
	add bx<span class="token punctuation">,</span>cx			<span class="token operator">!</span> 调整当前段内数据开始的位置
	jnc rp_read
	mov ax<span class="token punctuation">,</span>es
	add ax<span class="token punctuation">,</span>#<span class="token number">0x1000</span>
	mov es<span class="token punctuation">,</span>ax
	xor bx<span class="token punctuation">,</span>bx
	jmp rp_read

read_track<span class="token operator">:</span>
	push ax
	push bx
	push cx
	push dx
	mov dx<span class="token punctuation">,</span>track	<span class="token operator">!</span> 当前磁道号
	mov cx<span class="token punctuation">,</span>sread	<span class="token operator">!</span> 当前磁道已读扇区数
	inc cx			<span class="token operator">!</span> 从下一扇区开始读
	mov ch<span class="token punctuation">,</span>dl
	mov dx<span class="token punctuation">,</span>head		<span class="token operator">!</span> 当前磁头号
	mov dh<span class="token punctuation">,</span>dl
	mov dl<span class="token punctuation">,</span>#<span class="token number">0</span>
	and dx<span class="token punctuation">,</span>#<span class="token number">0x0100</span>
	mov ah<span class="token punctuation">,</span>#<span class="token number">2</span>
	<span class="token keyword">int</span> <span class="token number">0x13</span>
	jc bad_rt
	pop dx
	pop cx
	pop bx
	pop ax
	ret
bad_rt<span class="token operator">:</span>	mov ax<span class="token punctuation">,</span>#<span class="token number">0</span>	<span class="token operator">!</span> 执行驱动器复位操作
	mov dx<span class="token punctuation">,</span>#<span class="token number">0</span>
	<span class="token keyword">int</span> <span class="token number">0x13</span>
	pop dx
	pop cx
	pop bx
	pop ax
	jmp read_track
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>③bootsect跳转到setup处</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">SETUPSEG <span class="token operator">=</span> <span class="token number">0x9020</span>			<span class="token operator">!</span> setup starts here
	jmpi	<span class="token number">0</span><span class="token punctuation">,</span>SETUPSEG		<span class="token operator">!</span> 跳转到 setup<span class="token punctuation">.</span>s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>④setup将system移动到0x00000处</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">	mov	ax<span class="token punctuation">,</span>#<span class="token number">0x0000</span>
	cld			<span class="token operator">!</span> <span class="token char">'direction'</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> movs moves forward
do_move<span class="token operator">:</span>
	mov	es<span class="token punctuation">,</span>ax		<span class="token operator">!</span> destination segment
	add	ax<span class="token punctuation">,</span>#<span class="token number">0x1000</span>
	cmp	ax<span class="token punctuation">,</span>#<span class="token number">0x9000</span>
	jz	end_move
	mov	ds<span class="token punctuation">,</span>ax		<span class="token operator">!</span> source segment
	sub	di<span class="token punctuation">,</span>di
	sub	si<span class="token punctuation">,</span>si
	mov 	cx<span class="token punctuation">,</span>#<span class="token number">0x8000</span>
	rep
	movsw
	jmp	do_move
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>⑤setup加载GDT，令内核代码段基址指向第一条指令，即0x0处</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">!</span> 内核代码段
	<span class="token punctuation">.</span>word	<span class="token number">0x07FF</span>		<span class="token operator">!</span> <span class="token number">8</span>Mb <span class="token operator">-</span> limit<span class="token operator">=</span><span class="token number">2047</span> <span class="token punctuation">(</span><span class="token number">2048</span><span class="token operator">*</span><span class="token number">4096</span><span class="token operator">=</span><span class="token number">8</span>Mb<span class="token punctuation">)</span>
	<span class="token punctuation">.</span>word	<span class="token number">0x0000</span>		<span class="token operator">!</span> base address<span class="token operator">=</span><span class="token number">0</span>
	<span class="token punctuation">.</span>word	<span class="token number">0x9A00</span>		<span class="token operator">!</span> code read<span class="token operator">/</span>exec
	<span class="token punctuation">.</span>word	<span class="token number">0x00C0</span>		<span class="token operator">!</span> granularity<span class="token operator">=</span><span class="token number">4096</span><span class="token punctuation">,</span> <span class="token number">386</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>⑥setup进入保护模式，通过内核代码段选择子和偏移量跳转到head</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">jmpi	<span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span>		<span class="token operator">!</span> jmp offset <span class="token number">0</span> of segment <span class="token number">8</span> <span class="token punctuation">(</span>cs<span class="token punctuation">)</span>		进入 head<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="5-setup程序的最后是jmpi-0-8-，为什么这个8不能简单的当作阿拉伯数字8看待，究竟有什么内涵？"><a href="#5-setup程序的最后是jmpi-0-8-，为什么这个8不能简单的当作阿拉伯数字8看待，究竟有什么内涵？" class="headerlink" title="5.setup程序的最后是jmpi 0,8 ，为什么这个8不能简单的当作阿拉伯数字8看待，究竟有什么内涵？"></a>5.setup程序的最后是jmpi 0,8 ，为什么这个8不能简单的当作阿拉伯数字8看待，究竟有什么内涵？</h3><p>因为此时已经进入了保护模式，这里的0和8代表的是段内偏移量和段选择子。根据段选择子的规则，这里的8应该看做二进制的1000，其中最后两个字符“00”表示内核特权级，第二个字符“0”表示选择GDT表，第一个字符“1”表示所选择的表的第一项，即GDT表的第一项，由此来确定代码段的段基址和段限长，由此可以得到这段代码的意思是从0x00000000位置，偏移量为0处开始执行，即head的起始位置</p>
<h3 id="6-保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？为什么特权级是基于段的？"><a href="#6-保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？为什么特权级是基于段的？" class="headerlink" title="6.保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？为什么特权级是基于段的？"></a>6.保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？为什么特权级是基于段的？</h3><p>①打开了保护模式后，CPU的寻址模式发生了变化，需要依赖于GDT去获取代码或数据段的基址。从GDT可以看出，保护模式除了段基址外，还有段限长，这样相当于增加了一个段位寄存器。既有效地防止了对代码或数据段的覆盖，又防止了代码段自身的访问超限，明显增强了保护作用。<br>②体现：①在GDT、LDT及IDT中，均有自己界限特、权级等属性，这是对描述符所描述的对象的保护；②在不同特权级间访问时，系统会对CPL、RPL、DPL、IOPL 等进行检验，对不同层级的程序进行保护，同还限制某些特殊指令的使用，如 lgdt, lidt,cli等。<br>③特权级的目的和意义：①为了更好的管理资源并保护系统不受侵害，操作系统利用先机，以时间换取特权，先霸占所有特权；②依托CPU提供的保护模式，着眼于“段”，在所有的段选择符最后两位标示特权级，禁止用户执行cli、sti等对掌控局面至关重要的指令。③操作系统可以把内核设计成最高特权级，把用户进程设计成最低特权级。这样，操作系统可以访问 GDT、LDT、TR，而 GDT、LDT是逻辑地址形成线性地址的关键，因此操作系统可以掌控线性地址。物理地址是由内核将线性地址转换而成的，所以操作系统可以访问任何物理地址，而用户进程只能使用逻辑地址。<br>④分页机制中PDE和PTE中的R/W和U/S等，提供了页级保护；分页机制将线性地址与物理地址加以映射，提供了对物理地址的保护；通过分页机制，每个进程都有自己的专属页表，有利于更安全、高效的使用内存，保护每个进程的地址空间。</p>
<p>⑤在操作系统设计中，一个段一般实现的功能相对完整，可以把代码放在一个段，数据放在一个段，并通过段选择符（包括CS、SS、DS、ES、Fs和GS）获取段的基址和特权级等信息。通过段，系统划分了内核代码段、内核数据段、用户代码段和用户数据段等不同的数据段，有些段是系统专享的，有些是和用户程序共享的，因此就有特权级的概念。特权级基于段，这样当段选择子具有不匹配的特权级时，按照特权级规则评判是否可以访问。特权级基于段，是结合了程序的特点和硬件实现的一种考虑。</p>
<h3 id="7-在setup程序里曾经设置过gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么设置两次，而不是一次搞好？"><a href="#7-在setup程序里曾经设置过gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么设置两次，而不是一次搞好？" class="headerlink" title="7.在setup程序里曾经设置过gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么设置两次，而不是一次搞好？"></a>7.在setup程序里曾经设置过gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么设置两次，而不是一次搞好？</h3><p>原来GDT所在的位置是设计代码时在setup.s里面设置的数据，将来这个setup模块所在的内存位置会在设计缓冲区时被覆盖。如果不改变位置，将来GDT的内容肯定会被缓冲区覆盖掉，从而影响系统的运行。这样一来，将来整个内存空间中唯一安全的地方就是现在head.s所在的位置了。<br>不能在执行setup程序时直接把GDT的内容复制到head.s所在位置：如果先复制GDT内容，后移动system模块，它就会被后者覆盖；如果先移动system模块，后复制GDT内容，它又会把head.s对应的程序覆盖，而这时head.s还没有执行。所以无论如何都要重新建立GDT。</p>
<h3 id="8-内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。"><a href="#8-内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。" class="headerlink" title="8.内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。"></a>8.内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。</h3><p>①head.s在setup_paging开始创建分页机制。将页目录表和4个页表放到物理内存的起始位置，从内存起始位置开始的5个页空间内容全部清零（每页4kb），然后设置页目录表的前4项，使之分别指向4个页表。然后开始从高地址向低地址方向填写4个页表，依次指向内存从高地址向低地址方向的各个页面。即将第4个页表的最后一项（pg3+4092指向的位置）指向寻址范围的最后一个页面。即从0xFFF000开始的4kb 大小的内存空间。将第4个页表的倒数第二个页表项（pg3-4+4092）指向倒数第二个页面，即0xFFF000-0x1000开始的4KB字节的内存空间，依此类推。</p>
<p>②</p>
<p><img src="/posts/22763.htm/image-20231223120616068.png" alt></p>
<p>③Head.s中完成页表项与页面的挂接，是从高地址向低地址方向完成挂接的，16M内存全部完成挂接（页表从0开始，即页表0-页表3）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">setup_paging<span class="token operator">:</span> 
movl $<span class="token number">1024</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">%</span>ecx  <span class="token comment">/* 5 pages - pg_dir+4 page tables */</span> 
xorl <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>eax 
xorl <span class="token operator">%</span>edi<span class="token punctuation">,</span><span class="token operator">%</span>edi  <span class="token comment">/* pg_dir is at 0x000 */</span> 
cld<span class="token punctuation">;</span>rep<span class="token punctuation">;</span>stosl
 movl $pg0<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">,</span>pg_dir  <span class="token comment">/* set present bit/user r/w */</span>  
movl $pg1<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">,</span>pg_dir<span class="token operator">+</span><span class="token number">4</span>  <span class="token comment">/*  --------- " " --------- */</span> 
movl $pg2<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">,</span>pg_dir<span class="token operator">+</span><span class="token number">8</span>  <span class="token comment">/*  --------- " " --------- */</span>  
movl $pg3<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">,</span>pg_dir<span class="token operator">+</span><span class="token number">12</span>  <span class="token comment">/*  --------- " " --------- */</span> 
_pg_dir用于表示内核分页机制完成后的内核起始位置，也就是物理内存的起始位置<span class="token number">0x000000</span>，以上四句完成页目录表的前四项与页表<span class="token number">1</span>，<span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span>的挂接 
movl $pg3<span class="token operator">+</span><span class="token number">4092</span><span class="token punctuation">,</span><span class="token operator">%</span>edi 
movl $<span class="token number">0xfff007</span><span class="token punctuation">,</span><span class="token operator">%</span>eax  <span class="token comment">/*  16Mb - 4096 + 7 (r/w user,p) */</span> 
std 
<span class="token number">1</span><span class="token operator">:</span> 	stosl   <span class="token comment">/* fill pages backwards - more efficient :-) */</span> 
subl $<span class="token number">0x1000</span><span class="token punctuation">,</span><span class="token operator">%</span>eax
	jge <span class="token number">1</span>b
	xorl <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>eax		<span class="token comment">/* pg_dir is at 0x0000 */</span>
	movl <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>cr3		<span class="token comment">/* cr3 - page directory start */</span>
	movl <span class="token operator">%</span>cr0<span class="token punctuation">,</span><span class="token operator">%</span>eax
	orl $<span class="token number">0x80000000</span><span class="token punctuation">,</span><span class="token operator">%</span>eax
	movl <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>cr0		<span class="token comment">/* set paging (PG) bit */</span>
	ret			<span class="token comment">/* this also flushes prefetch-queue */</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="9-根据内核分页为线性地址恒等映射的要求，推导出四个页表的映射公式，写出页表的设置代码。"><a href="#9-根据内核分页为线性地址恒等映射的要求，推导出四个页表的映射公式，写出页表的设置代码。" class="headerlink" title="9.根据内核分页为线性地址恒等映射的要求，推导出四个页表的映射公式，写出页表的设置代码。"></a>9.根据内核分页为线性地址恒等映射的要求，推导出四个页表的映射公式，写出页表的设置代码。</h3><p>内核分页采用线性地址恒等映射。内核的段基址是0，代码段和数据段的段限长都是16 MB。每个页面大小为4 KB，每个页表可以管理1024个页面，每个页目录表可以管理1024个页表。既然确定了段限长是16 MB，这样就需要4个页目录项（attention：只用了四个页目录项管理4个页表）下辖4个页表，来管理这16 MB的内存</p>
<p><img src="/posts/22763.htm/image-20231224200141195.png" alt></p>
<p>页表设置代码：(内核分页采用恒等映射模式，调用get_free_page( )函数后，获取的线性地址值直接就可以当物理地址来用)</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//代码路径：boot/head.s:</span>
…
setup_paging<span class="token operator">:</span>
      movl $<span class="token number">1024</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">%</span>ecx            <span class="token comment">/* 5 pages - pg_dir + 4 page tables */</span>
      xorl <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>eax
      xorl <span class="token operator">%</span>edi<span class="token punctuation">,</span><span class="token operator">%</span>edi                       <span class="token comment">/* pg_dir is at 0x000 */</span>
      cld<span class="token punctuation">;</span>rep<span class="token punctuation">;</span>stosl
      movl $pg0 <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">,</span>_pg_dir                <span class="token comment">/* set present bit/user r/w */</span>
      movl $pg1 <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">,</span>_pg_dir <span class="token operator">+</span> <span class="token number">4</span>    <span class="token comment">/*  --------- " " --------- */</span>
      movl $pg2 <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">,</span>_pg_dir <span class="token operator">+</span> <span class="token number">8</span>    <span class="token comment">/*  --------- " " --------- */</span>
      movl $pg3 <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">,</span>_pg_dir <span class="token operator">+</span> <span class="token number">12</span>  <span class="token comment">/*  --------- " " --------- */</span>
      movl $pg3 <span class="token operator">+</span> <span class="token number">4092</span><span class="token punctuation">,</span><span class="token operator">%</span>edi
      movl $<span class="token number">0xfff007</span><span class="token punctuation">,</span><span class="token operator">%</span>eax          <span class="token comment">/*  16Mb -4096 + 7 (r/w user,p) */</span>
      std
<span class="token number">1</span><span class="token operator">:</span> stosl                          <span class="token comment">/* fill pages backwards - more efficient :-) */</span>
      subl $<span class="token number">0x1000</span><span class="token punctuation">,</span><span class="token operator">%</span>eax
      jge <span class="token number">1</span>b
…
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="10-为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。"><a href="#10-为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。" class="headerlink" title="10.为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。"></a>10.为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。</h3><p>call指令会将EIP的值自动压栈，保护返回现场，然后执行被调用函数的程序，等执行到函数的ret指令时，自动出栈给EIP返回调用前的现场，而后继续执行call的下一条指令。然而由于操作系统是机器运行时逻辑上最底层的代码，因此如果使用call来调用操作系统的main函数，那么执行到ret时没有一个更底层的函数来接收操作系统的返回。而如果使用ret来实现调用main函数的操作则不需要再返回了。要想用ret来模拟call指令调用main函数，则需要手动编写压栈和跳转动作的代码。</p>
<p>调用路线如图：</p>
<p><img src="/posts/22763.htm/image-20231221222053356.png" alt></p>
<p>代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">after_page_tables<span class="token operator">:</span>
	pushl $<span class="token number">0</span>		# These are the parameters to main <span class="token operator">:</span><span class="token operator">-</span><span class="token punctuation">)</span>	envp
	pushl $<span class="token number">0</span>		# argv
	pushl $<span class="token number">0</span>		# argc
	pushl $L6		# <span class="token keyword">return</span> address <span class="token keyword">for</span> main<span class="token punctuation">,</span> <span class="token keyword">if</span> it decides to<span class="token punctuation">.</span>
	pushl $_main	# kernel 的 main 函数地址
	jmp setup_paging
L6<span class="token operator">:</span>
	jmp L6			# main should never <span class="token keyword">return</span> here<span class="token punctuation">,</span> but
				<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">just</span> <span class="token expression">in <span class="token keyword">case</span><span class="token punctuation">,</span> we know what happens<span class="token punctuation">.</span></span></span>

setup_paging<span class="token operator">:</span>	<span class="token comment">// 内核分页，分完以后 线性地址 == 物理地址</span>
	<span class="token comment">// ...</span>
	ret			<span class="token comment">/* this also flushes prefetch-queue */</span>		<span class="token comment">// 我们是操作系统的底层，所以要返回到 kernel 中</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="11、计算内核代码段、数据段的段基址、段限长、特权级。"><a href="#11、计算内核代码段、数据段的段基址、段限长、特权级。" class="headerlink" title="11、计算内核代码段、数据段的段基址、段限长、特权级。"></a>11、计算内核代码段、数据段的段基址、段限长、特权级。</h3><p>在 Linux 0.11 中，内核代码段和数据段的段基址实际上是相同的，都是 0x00000000；代码段和数据段的段限长均设置为16 MB；特权级为0特权级</p>
<h3 id="12、计算进程0的代码段、数据段的段基址、段限长、特权级。"><a href="#12、计算进程0的代码段、数据段的段基址、段限长、特权级。" class="headerlink" title="12、计算进程0的代码段、数据段的段基址、段限长、特权级。"></a>12、计算进程0的代码段、数据段的段基址、段限长、特权级。</h3><p>在 Linux 0.11 中，进程0的代码段和数据段的段基址都是 0x00000000；代码段和数据段的段限长均设置为160*4KB=640KB；特权级为0特权级</p>
<h3 id="13、fork进程1之前，为什么先调用move-to-user-mode-？用的是什么方法？解释其中的道理。"><a href="#13、fork进程1之前，为什么先调用move-to-user-mode-？用的是什么方法？解释其中的道理。" class="headerlink" title="13、fork进程1之前，为什么先调用move_to_user_mode()？用的是什么方法？解释其中的道理。"></a>13、fork进程1之前，为什么先调用move_to_user_mode()？用的是什么方法？解释其中的道理。</h3><p>①因为在Linux-011中，规定除了进程0以外的所有进程，都必须在特权级为3即用户模式中开始执行。所以进程0 fork进程1之前，要调用move_to_user_mode()将0特权级翻转到3特权级。<br>②move_to_user_mode()使用的方法是模仿中断的硬件压栈，将ss、esp、eflags、cs、eip按顺序压栈，然后执行iret从内核模式返回，出栈恢复现场，从而翻转0特权级到3特权级。<br>③CPU响应中断的时候，根据DPL的设置，可以实现指定的特权级之间的翻转。所以模拟中断硬件压栈可以实现特权级的翻转。</p>
<h3 id="14、根据什么判定move-to-user-mode-中iret之后的代码为进程0的代码。"><a href="#14、根据什么判定move-to-user-mode-中iret之后的代码为进程0的代码。" class="headerlink" title="14、根据什么判定move_to_user_mode()中iret之后的代码为进程0的代码。"></a>14、根据什么判定move_to_user_mode()中iret之后的代码为进程0的代码。</h3><p>iret 指令将CPU状态从内核模式切换到用户模式。iret之后的代码目的是为了设置用户模式下的各种寄存器。move_to_user_mode 是在系统初始化的最后阶段调用的，且此时系统中只有进程0存在，进程1还未创建。因此iret指令之后的代码仍然是属于进程0的。</p>
<h3 id="15、进程0的task-struct在哪？具体内容是什么？给出代码证据。"><a href="#15、进程0的task-struct在哪？具体内容是什么？给出代码证据。" class="headerlink" title="15、进程0的task_struct在哪？具体内容是什么？给出代码证据。"></a>15、进程0的task_struct在哪？具体内容是什么？给出代码证据。</h3><p>①进程0的task_struct是操作系统设计者事先设计好的，位于内核数据区。<br>②进程0的task_struct 的具体内容包含了进程0的状态、信号、pid、alarm、ldt、tss等管理该进程所需的数据。<br>③代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 进程0的task_struct</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INIT_TASK</span> <span class="token punctuation">\</span>
<span class="token comment">/* state etc */</span>	<span class="token expression"><span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token comment">/* signals */</span>	<span class="token expression"><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token comment">/* ec,brk... */</span>	<span class="token expression"><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token comment">/* pid etc.. */</span>	<span class="token expression"><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token comment">/* uid etc */</span>	<span class="token expression"><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token comment">/* alarm */</span>	<span class="token expression"><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token comment">/* math */</span>	<span class="token expression"><span class="token number">0</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token comment">/* fs info */</span>	<span class="token expression"><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0022</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token comment">/* filp */</span>	<span class="token expression"><span class="token punctuation">&#123;</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">&#123;</span> </span><span class="token punctuation">\</span>
		<span class="token expression"><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token comment">/* ldt */</span>	<span class="token expression"><span class="token punctuation">&#123;</span><span class="token number">0x9f</span><span class="token punctuation">,</span><span class="token number">0xc0fa00</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
		<span class="token expression"><span class="token punctuation">&#123;</span><span class="token number">0x9f</span><span class="token punctuation">,</span><span class="token number">0xc0f200</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token comment">/*tss*/</span>	<span class="token expression"><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span>PAGE_SIZE<span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>init_task<span class="token punctuation">,</span><span class="token number">0x10</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>pg_dir<span class="token punctuation">,</span></span><span class="token punctuation">\</span>
	 <span class="token expression"><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
	 <span class="token expression"><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0x17</span><span class="token punctuation">,</span><span class="token number">0x17</span><span class="token punctuation">,</span><span class="token number">0x17</span><span class="token punctuation">,</span><span class="token number">0x17</span><span class="token punctuation">,</span><span class="token number">0x17</span><span class="token punctuation">,</span><span class="token number">0x17</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
	 <span class="token expression"><span class="token function">_LDT</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0x80000000</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
		<span class="token expression"><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> </span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">&#125;</span></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="16、在system-h里，有以下代码。读懂代码。这里中断门、陷阱门、系统调用都是通过-set-gate设置的，用的是同一个嵌入汇编代码，比较明显的差别是dpl一个是3，另外两个是0，这是为什么？说明理由。"><a href="#16、在system-h里，有以下代码。读懂代码。这里中断门、陷阱门、系统调用都是通过-set-gate设置的，用的是同一个嵌入汇编代码，比较明显的差别是dpl一个是3，另外两个是0，这是为什么？说明理由。" class="headerlink" title="16、在system.h里，有以下代码。读懂代码。这里中断门、陷阱门、系统调用都是通过_set_gate设置的，用的是同一个嵌入汇编代码，比较明显的差别是dpl一个是3，另外两个是0，这是为什么？说明理由。"></a>16、在system.h里，有以下代码。读懂代码。这里中断门、陷阱门、系统调用都是通过_set_gate设置的，用的是同一个嵌入汇编代码，比较明显的差别是dpl一个是3，另外两个是0，这是为什么？说明理由。</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _set_gate(gate_addr,type,dpl,addr) \
__asm__ (&quot;movw %%dx,%%ax\n\t&quot; \
    &quot;movw %0,%%dx\n\t&quot; \
    &quot;movl %%eax,%1\n\t&quot; \
    &quot;movl %%edx,%2&quot; \
    : \
    : &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \
    &quot;o&quot; (*((char *) (gate_addr))), \
    &quot;o&quot; (*(4+(char *) (gate_addr))), \
    &quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000))

#define set_intr_gate(n,addr) \
    _set_gate(&amp;idt[n],14,0,addr)

#define set_trap_gate(n,addr) \
    _set_gate(&amp;idt[n],15,0,addr)

#define set_system_gate(n,addr) \
    _set_gate(&amp;idt[n],15,3,addr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>dpl表示的是特权级，0和3分别表示0特权级（内核级）和3特权级（用户级），内核级高于用户级。中断和异常处理是由内核来完成的，Linux出于对内核的保护，不允许用户进程直接访问内核，因此需要设置为0特权级。但是有些情况下，用户进程又需要内核代码的支持，因此就需要系统调用，它是用户进程与内核打交道的接口，是由用户进程直接调用的。因此其在3特权级下。</p>
<h3 id="17、分析get-free-page-函数的代码，叙述在主内存中获取一个空闲页的技术路线。"><a href="#17、分析get-free-page-函数的代码，叙述在主内存中获取一个空闲页的技术路线。" class="headerlink" title="17、分析get_free_page()函数的代码，叙述在主内存中获取一个空闲页的技术路线。"></a>17、分析get_free_page()函数的代码，叙述在主内存中获取一个空闲页的技术路线。</h3><p>①将EAX 设置为0,EDI 设置指向mem_map 的最后一项（mem_map+PAGING_PAGES-1），std设置扫描是从高地址向低地址。从mem_map的最后一项反向扫描，找出引用次数为0(AL)的页，如果没有则退出；如果找到，则将找到的页设引用数为1；<br>② ECX左移12位得到页的相对地址，加LOW_MEM得到物理地址，将此页最后一个字节的地址赋值给EDI（LOW_MEM+4092）；<br>③ stosl将EAX的值设置到ES:EDI所指内存，即反向清零1024*32bit，将此页清空；<br>④ 将页的地址（存放在EAX）返回。</p>
<h3 id="18、copy-process函数的参数最后五项是：long-eip-long-cs-long-eflags-long-esp-long-ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。详细论证其他所有参数是如何传入的。"><a href="#18、copy-process函数的参数最后五项是：long-eip-long-cs-long-eflags-long-esp-long-ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。详细论证其他所有参数是如何传入的。" class="headerlink" title="18、copy_process函数的参数最后五项是：long eip,long cs,long eflags,long esp,long ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。详细论证其他所有参数是如何传入的。"></a>18、copy_process函数的参数最后五项是：long eip,long cs,long eflags,long esp,long ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。详细论证其他所有参数是如何传入的。</h3><p>copy_process执行时因为进程调用了fork函数，会导致中断，中断使CPU硬件自动将SS、ESP、EFLAGS、CS、EIP这几个寄存器的值按照顺序压入 进程0内核栈，又因为函数专递参数是使用栈的，所以刚好可以做为copy_process的最后五项参数。</p>
<h3 id="19、详细分析Linux操作系统如何设置保护模式的中断机制。"><a href="#19、详细分析Linux操作系统如何设置保护模式的中断机制。" class="headerlink" title="19、详细分析Linux操作系统如何设置保护模式的中断机制。"></a>19、详细分析Linux操作系统如何设置保护模式的中断机制。</h3><p>①中断描述符表 (IDT) 初始化:<br>在保护模式下，IDT用于存放中断处理程序的地址。每个中断或异常都有一个与之相关联的中断描述符。Linux在启动时设置这个IDT。</p>
<p>②初始化中断控制器 (PIC):<br>为了接收来自外部硬件的中断，Linux首先需要初始化可编程中断控制器 (PIC)。这是一个芯片，负责从外部硬件接收中断请求并将它们传递给CPU。</p>
<p>③设置中断处理程序:<br>Linux为每个可能的中断或异常设置了一个中断处理程序。这些处理程序在内核启动时初始化，并与特定的中断或异常号相关联。</p>
<p>④加载IDT寄存器:<br>使用lidt指令加载IDT的地址和大小。这告诉CPU在哪里可以找到中断描述符表。</p>
<p>⑤开启中断:<br>通过设置CPU的标志寄存器中的中断标志（IF）来启用中断。</p>
<h3 id="20、分析Linux操作系统如何剥夺用户进程访问内核及其他进程的能力。"><a href="#20、分析Linux操作系统如何剥夺用户进程访问内核及其他进程的能力。" class="headerlink" title="20、分析Linux操作系统如何剥夺用户进程访问内核及其他进程的能力。"></a>20、分析Linux操作系统如何剥夺用户进程访问内核及其他进程的能力。</h3><p>所有程序的设计都是基于段的。</p>
<p>①进程跨越到内核</p>
<p>用户进程代码段的特权级都是3，内核的特权级是0，Intel IA-32架构禁止代码跨越特权级长跳转，3特权级长跳转到0特权级是禁止的，0特权级长跳转到3特权级同样是禁止的。所以这样的非法长跳转指令会被CPU硬件有效阻拦，进程与内核的边界得到有效的保护。</p>
<p>②当一个进程的代码中有非法的跨进程跳转的指令时，比如，ljmp指令执行时，该指令后面的操作数是“段内偏移段选择子”。代码段的段选择子存储在CS里面。仔细考察一下，可以看出Linux 0.11中所有进程的CS的内容都是一样的，用二进制表示的形式都是0000000000001111。CPU硬件无法识别是哪一个进程的CS，也就无法选择段描述符，只能默认使用当前LDT中提供的段描述符，所以类似ljmp这样的段间跳转指令，无论后面操作数怎么写，都无法跨越当前进程的代码段，也就无法进行段间跳转，最终只能是执行到本段。</p>
<h3 id="21、-system-call中有以下代码，分析后面这两行代码的意义。"><a href="#21、-system-call中有以下代码，分析后面这两行代码的意义。" class="headerlink" title="21、_system_call中有以下代码，分析后面这两行代码的意义。"></a>21、_system_call中有以下代码，分析后面这两行代码的意义。</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">cmpl $nr_system_calls<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">%</span>eax
ja bad_sys_call<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>验证发起的系统调用编号是否在有效范围内，阻止非法的系统调用。</p>
<h3 id="22、分析copy-page-tables（）函数的代码，叙述父进程如何为子进程复制页表。"><a href="#22、分析copy-page-tables（）函数的代码，叙述父进程如何为子进程复制页表。" class="headerlink" title="22、分析copy_page_tables（）函数的代码，叙述父进程如何为子进程复制页表。"></a>22、分析copy_page_tables（）函数的代码，叙述父进程如何为子进程复制页表。</h3><p>①要求源地址和目的地址必须按 4MB 对齐；<br>②计算源地址和目的地址所在的页目录表项的线性地址；<br>③通过所占的地址空间计算所用的页目录表项数；<br>④根据页目录表项的起始线性地址和页目录表项数遍历页目录表，对每一个源页目录表项，如果对应的页表存在，则进行以下操作：<br>    4.1 从页目录表项中取出对应的页表的起始物理地址；<br>    4.2 为目的页表分配一个空白页，并挂到目的页目录表项上，并将标志设置为用户级的、可读写、存在；<br>    4.3 计算需要复制的页表项数，如果是内核空间(源地址为 0)，则只复制前 160 项(内核空间只占低 640 KB)，否则全部复制。<br>    4.4 遍历页表，对于每一个源页表项，如果对应的页存在，则进行以下操作：<br>           4.4.1 从源页表中复制每一项到目的页表，同时置为”只读”，以便进行 COW；<br>           4.4.2 如果页表项对应的页的地址在1MB 以上(非内核页面)，则将源页表项置为只读，并在 mem_map 中将该页的引用计数加 1；<br>⑤重新加载 cr3，刷新 TLB。</p>
<h3 id="23、进程0创建进程1时，为进程1建立了task-struct及内核栈，第一个页表，分别位于物理内存两个页。请问，这两个页的位置，究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。"><a href="#23、进程0创建进程1时，为进程1建立了task-struct及内核栈，第一个页表，分别位于物理内存两个页。请问，这两个页的位置，究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。" class="headerlink" title="23、进程0创建进程1时，为进程1建立了task_struct及内核栈，第一个页表，分别位于物理内存两个页。请问，这两个页的位置，究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。"></a>23、进程0创建进程1时，为进程1建立了task_struct及内核栈，第一个页表，分别位于物理内存两个页。请问，这两个页的位置，究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。</h3><p>均占用内核的线性地址空间，原因如下：</p>
<p>通过逆向扫描页表位图，并由第一空页的下标左移 12 位加 LOW_MEM 得到该页的物理地址，位于 16M 内存末端。 代码如下</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//代码路径：mm/memory.c</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">get_free_page</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">register</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> __res <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">"ax"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"std ; repne ; scasb\n\t"</span>
	<span class="token string">"jne 1f\n\t"</span>
	<span class="token string">"movb $1,1(%%edi)\n\t"</span>
	<span class="token string">"sall $12,%%ecx\n\t"</span>
	<span class="token string">"addl %2,%%ecx\n\t"</span>
	<span class="token string">"movl %%ecx,%%edx\n\t"</span>
	<span class="token string">"movl $1024,%%ecx\n\t"</span>
	<span class="token string">"leal 4092(%%edx),%%edi\n\t"</span>
	<span class="token string">"rep ; stosl\n\t"</span>
	<span class="token string">"movl %%edx,%%eax\n"</span>
	<span class="token string">"1:"</span>
	<span class="token operator">:</span><span class="token string">"=a"</span> <span class="token punctuation">(</span>__res<span class="token punctuation">)</span>
	<span class="token operator">:</span><span class="token string">"0"</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"i"</span> <span class="token punctuation">(</span>LOW_MEM<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"c"</span> <span class="token punctuation">(</span>PAGING_PAGES<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token string">"D"</span> <span class="token punctuation">(</span>mem_map<span class="token operator">+</span>PAGING_PAGES<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token operator">:</span><span class="token string">"di"</span><span class="token punctuation">,</span><span class="token string">"cx"</span><span class="token punctuation">,</span><span class="token string">"dx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> __res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>进程 0 和进程 1 的 LDT 的 LIMIT 属性将进程 0 和进程 1 的地址空间限定0~640KB， 所以进程 0、 进程 1 均无法访问到这两个页面， 故两页面占用内核的线性地址空间。进程 0 的局部描述符如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//代码路径：boot\head.s</span>
<span class="token punctuation">.</span>align <span class="token number">2</span>
setup_paging<span class="token operator">:</span>
	movl $<span class="token number">1024</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">%</span>ecx		<span class="token comment">/* 5 pages - pg_dir+4 page tables */</span>
	xorl <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>eax
	xorl <span class="token operator">%</span>edi<span class="token punctuation">,</span><span class="token operator">%</span>edi			<span class="token comment">/* pg_dir is at 0x000 */</span>
	cld<span class="token punctuation">;</span>rep<span class="token punctuation">;</span>stosl
	movl $pg0<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">,</span>_pg_dir		<span class="token comment">/* set present bit/user r/w */</span>
	movl $pg1<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">,</span>_pg_dir<span class="token operator">+</span><span class="token number">4</span>		<span class="token comment">/*  --------- " " --------- */</span>
	movl $pg2<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">,</span>_pg_dir<span class="token operator">+</span><span class="token number">8</span>		<span class="token comment">/*  --------- " " --------- */</span>
	movl $pg3<span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">,</span>_pg_dir<span class="token operator">+</span><span class="token number">12</span>		<span class="token comment">/*  --------- " " --------- */</span>
	movl $pg3<span class="token operator">+</span><span class="token number">4092</span><span class="token punctuation">,</span><span class="token operator">%</span>edi
	movl $<span class="token number">0xfff007</span><span class="token punctuation">,</span><span class="token operator">%</span>eax		<span class="token comment">/*  16Mb - 4096 + 7 (r/w user,p) */</span>
	std
<span class="token number">1</span><span class="token operator">:</span>	stosl			<span class="token comment">/* fill pages backwards - more efficient :-) */</span>
	subl $<span class="token number">0x1000</span><span class="token punctuation">,</span><span class="token operator">%</span>eax
	jge <span class="token number">1</span>b
	xorl <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>eax		<span class="token comment">/* pg_dir is at 0x0000 */</span>
	movl <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>cr3		<span class="token comment">/* cr3 - page directory start */</span>
	movl <span class="token operator">%</span>cr0<span class="token punctuation">,</span><span class="token operator">%</span>eax
	orl $<span class="token number">0x80000000</span><span class="token punctuation">,</span><span class="token operator">%</span>eax
	movl <span class="token operator">%</span>eax<span class="token punctuation">,</span><span class="token operator">%</span>cr0		<span class="token comment">/* set paging (PG) bit */</span>
	ret			<span class="token comment">/* this also flushes prefetch-queue */</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码，指明了内核的线性地址空间为0x000000~Oxffffff(即前16M），且线性地址与物理地址呈现一一对应的关系。为进程1分配的这两个页，在16MB的顶端倒数第一页、第二页，因此占用内核的线性地址空间。<br>进程0的线性地址空间是内存前640KB，因为进程0的LDT中的limit 属性限制了进程0能够访问的地址空间。进程1拷贝了进程0的页表（160项），而这160个页表项即为内核第一个页表的前160项，指向的是物理内存前640KB，因此无法访问到16MB的顶端倒数的两个页。<br>进程0创建进程1的时候，先后通过get_free_page函数从物理地址中取出了两个页，但是并没有将这两个页的物理地址填入任何新的页表项中。此时只有内核的页表中包含了与这段物理地址对应的项，也就是说此时只有内核页表中有页表项指向这两个页的首地址，所以这两个页占用了内核线性空间。</p>
<h3 id="24、假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。"><a href="#24、假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。" class="headerlink" title="24、假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。"></a>24、假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。</h3><p>这两个页面均占用内核的线性地址空间。既然是内核线性地址空间，则与物理地址空间为一一对应关系。根据每一个进程占用16个页目录表项，则进程4占用从第65～81项的页目录表项。同理，进程5占用第81～96项的页目录表项。因为目前只分配了一个页面（用作进程的第一个页表），则分别只须要使用第一个页目录表项便可。映射关系如图：</p>
<p><img src="/posts/22763.htm/image-20231224210848666.png" alt></p>
<h3 id="25、有以下代码，代码中的”ljmp-0-n-t”-很奇怪，按理说jmp指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了”m”-amp-tmp-a-，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。"><a href="#25、有以下代码，代码中的”ljmp-0-n-t”-很奇怪，按理说jmp指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了”m”-amp-tmp-a-，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。" class="headerlink" title="25、有以下代码，代码中的”ljmp %0\n\t” 很奇怪，按理说jmp指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了”m” (*&amp;__tmp.a)，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。"></a>25、有以下代码，代码中的”ljmp %0\n\t” 很奇怪，按理说jmp指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了”m” (*&amp;__tmp.a)，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">switch_to</span><span class="token expression"><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></span><span class="token punctuation">\</span>
<span class="token expression"><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token keyword">long</span> a<span class="token punctuation">,</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> __tmp<span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token function">__asm__</span><span class="token punctuation">(</span></span><span class="token string">"cmpl %%ecx,_current\n\t"</span> <span class="token punctuation">\</span>
   <span class="token string">"je 1f\n\t"</span> <span class="token punctuation">\</span>
   <span class="token string">"movw %%dx,%1\n\t"</span> <span class="token punctuation">\</span>
   <span class="token string">"xchgl %%ecx,_current\n\t"</span> <span class="token punctuation">\</span>
   <span class="token string">"ljmp %0\n\t"</span> <span class="token punctuation">\</span>
   <span class="token string">"cmpl %%ecx,_last_task_used_math\n\t"</span> <span class="token punctuation">\</span>
   <span class="token string">"jne 1f\n\t"</span> <span class="token punctuation">\</span>
   <span class="token string">"clts\n"</span> <span class="token punctuation">\</span>
   <span class="token string">"1:"</span> <span class="token punctuation">\</span>
   <span class="token expression"><span class="token operator">::</span></span><span class="token string">"m"</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">&amp;</span>__tmp<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span></span><span class="token string">"m"</span> <span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">&amp;</span>__tmp<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
   <span class="token string">"d"</span> <span class="token expression"><span class="token punctuation">(</span><span class="token function">_TSS</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span></span><span class="token string">"c"</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> task<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">&#125;</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>tmp.a 为偏移量，tmp.b 为段选择子。在上述代码中，CPU通过 movw %%dx,%1\n\t 指令,将当前寄存器的值保存到当前进程的TSS中，再将目标进程 n的TSS和LDT恢复给CPU的各寄存器，ljmp 加上 TSS 描述符的选择子tmp.b和偏移量tmp.a 就实现了进程的跳转。</p>
<h3 id="26、进程0开始创建进程1，调用fork（），跟踪代码时我们发现，fork代码执行了两次，第一次，执行fork代码后，跳过init（）直接执行了for-pause-，第二次执行fork代码后，执行了init（）。奇怪的是，我们在代码中并没有看到向转向fork的goto语句，也没有看到循环语句，是什么原因导致fork反复执行？请说明理由（可以图示），并给出代码证据。"><a href="#26、进程0开始创建进程1，调用fork（），跟踪代码时我们发现，fork代码执行了两次，第一次，执行fork代码后，跳过init（）直接执行了for-pause-，第二次执行fork代码后，执行了init（）。奇怪的是，我们在代码中并没有看到向转向fork的goto语句，也没有看到循环语句，是什么原因导致fork反复执行？请说明理由（可以图示），并给出代码证据。" class="headerlink" title="26、进程0开始创建进程1，调用fork（），跟踪代码时我们发现，fork代码执行了两次，第一次，执行fork代码后，跳过init（）直接执行了for(;;) pause()，第二次执行fork代码后，执行了init（）。奇怪的是，我们在代码中并没有看到向转向fork的goto语句，也没有看到循环语句，是什么原因导致fork反复执行？请说明理由（可以图示），并给出代码证据。"></a>26、进程0开始创建进程1，调用fork（），跟踪代码时我们发现，fork代码执行了两次，第一次，执行fork代码后，跳过init（）直接执行了for(;;) pause()，第二次执行fork代码后，执行了init（）。奇怪的是，我们在代码中并没有看到向转向fork的goto语句，也没有看到循环语句，是什么原因导致fork反复执行？请说明理由（可以图示），并给出代码证据。</h3><p>fork 为 inline 函数，其中调用了 sys_call0，产生 0x80 中断，将 ss, esp, eflags, cs, eip 压栈，其中 eip 为 int 0x80 的下一句的地址。在 copy_process 中，内核将进程 0 的 tss 复制得到进程 1 的 tss，并将进程 1 的 tss.eax 设为 0，而进程 0 中的 eax 为 1。在进程调度时 tss 中的值被恢复至相应寄存器中，包括 eip， eax 等。所以中断返回后，进程 0 和进程 1 均会从 int 0x80 的下一句开始执行，即 fork 执行了两次。</p>
<p>由于 eax 代表返回值，所以进程 0 和进程 1 会得到不同的返回值，在fork返回到进程0后，进程0判断返回值非 0，因此执行代码for(;😉 pause();</p>
<p>在sys_pause函数中，内核设置了进程0的状态为 TASK_INTERRUPTIBLE，并进行进程调度。由于只有进程1处于就绪态，因此调度执行进程1的指令。由于进程1在TSS中设置了eip等寄存器的值，因此从 int 0x80 的下一条指令开始执行，且设定返回 eax 的值作为 fork 的返回值（值为 0），因此进程1执行了 init 的 函数。导致反复执行，主要是利用了两个系统调用 sys_fork 和 sys_pause 对进程状态的设置，以及利用了进程调度机制。<br>代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//代码路径：init/main.c</span>
<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>	<span class="token punctuation">&#123;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token function">move_to_user_mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//fork的返回值为1，if(!1)为假		/* we count on this going ok */</span>
		<span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不会执行这一行</span>
	<span class="token punctuation">&#125;</span>
<span class="token comment">//代码路径：include/unistd.h</span>
<span class="token keyword">int</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> \
<span class="token punctuation">&#123;</span> \
<span class="token keyword">long</span> __res<span class="token punctuation">;</span> \
__asm__ <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"int $0x80"</span> \
	<span class="token operator">:</span> <span class="token string">"=a"</span> <span class="token punctuation">(</span>__res<span class="token punctuation">)</span> \ <span class="token comment">//__res的值就是eax，是copy_process（）的返回值last_pid（1）</span>
	<span class="token operator">:</span> <span class="token string">"0"</span> <span class="token punctuation">(</span>__NR_##name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \
<span class="token keyword">if</span> <span class="token punctuation">(</span>__res <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> \ <span class="token comment">//iret后，执行这一行！__res就是eax，值是1</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> __res<span class="token punctuation">;</span> \ <span class="token comment">//返回1！</span>
errno <span class="token operator">=</span> <span class="token operator">-</span>__res<span class="token punctuation">;</span> \
<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> \
<span class="token punctuation">&#125;</span>
<span class="token comment">//代码路径：kernel/fork.c</span>
<span class="token keyword">int</span> <span class="token function">copy_process</span><span class="token punctuation">(</span><span class="token keyword">int</span> nr<span class="token punctuation">,</span><span class="token keyword">long</span> ebp<span class="token punctuation">,</span><span class="token keyword">long</span> edi<span class="token punctuation">,</span><span class="token keyword">long</span> esi<span class="token punctuation">,</span><span class="token keyword">long</span> gs<span class="token punctuation">,</span><span class="token keyword">long</span> none<span class="token punctuation">,</span>
		<span class="token keyword">long</span> ebx<span class="token punctuation">,</span><span class="token keyword">long</span> ecx<span class="token punctuation">,</span><span class="token keyword">long</span> edx<span class="token punctuation">,</span>
		<span class="token keyword">long</span> fs<span class="token punctuation">,</span><span class="token keyword">long</span> es<span class="token punctuation">,</span><span class="token keyword">long</span> ds<span class="token punctuation">,</span>
		<span class="token keyword">long</span> eip<span class="token punctuation">,</span><span class="token keyword">long</span> cs<span class="token punctuation">,</span><span class="token keyword">long</span> eflags<span class="token punctuation">,</span><span class="token keyword">long</span> esp<span class="token punctuation">,</span><span class="token keyword">long</span> ss<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>

	p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">get_free_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>
	task<span class="token punctuation">[</span>nr<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
	<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">*</span>current<span class="token punctuation">;</span>	<span class="token comment">/* NOTE! this doesn't copy the supervisor stack */</span>
	p<span class="token operator">-></span>state <span class="token operator">=</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">;</span>
	p<span class="token operator">-></span>pid <span class="token operator">=</span> last_pid<span class="token punctuation">;</span>
	p<span class="token operator">-></span>father <span class="token operator">=</span> current<span class="token operator">-></span>pid<span class="token punctuation">;</span>
	p<span class="token operator">-></span>counter <span class="token operator">=</span> p<span class="token operator">-></span>priority<span class="token punctuation">;</span>
	p<span class="token operator">-></span>signal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>alarm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>leader <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>		<span class="token comment">/* process leadership doesn't inherit */</span>
	p<span class="token operator">-></span>utime <span class="token operator">=</span> p<span class="token operator">-></span>stime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>cutime <span class="token operator">=</span> p<span class="token operator">-></span>cstime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>start_time <span class="token operator">=</span> jiffies<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>back_link <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>esp0 <span class="token operator">=</span> PAGE_SIZE <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> p<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>ss0 <span class="token operator">=</span> <span class="token number">0x10</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>eip <span class="token operator">=</span> eip<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>eflags <span class="token operator">=</span> eflags<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>eax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>ecx <span class="token operator">=</span> ecx<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>edx <span class="token operator">=</span> edx<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>ebx <span class="token operator">=</span> ebx<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>esp <span class="token operator">=</span> esp<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>ebp <span class="token operator">=</span> ebp<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>esi <span class="token operator">=</span> esi<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>edi <span class="token operator">=</span> edi<span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>es <span class="token operator">=</span> es <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>cs <span class="token operator">=</span> cs <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>ss <span class="token operator">=</span> ss <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>ds <span class="token operator">=</span> ds <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>fs <span class="token operator">=</span> fs <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>gs <span class="token operator">=</span> gs <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>ldt <span class="token operator">=</span> <span class="token function">_LDT</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>tss<span class="token punctuation">.</span>trace_bitmap <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>last_task_used_math <span class="token operator">==</span> current<span class="token punctuation">)</span>
		<span class="token function">__asm__</span><span class="token punctuation">(</span><span class="token string">"clts ; fnsave %0"</span><span class="token operator">::</span><span class="token string">"m"</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>tss<span class="token punctuation">.</span>i387<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_mem</span><span class="token punctuation">(</span>nr<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		task<span class="token punctuation">[</span>nr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token function">free_page</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span>EAGAIN<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>NR_OPEN<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token operator">=</span>p<span class="token operator">-></span>filp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
			f<span class="token operator">-></span>f_count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>pwd<span class="token punctuation">)</span>
		current<span class="token operator">-></span>pwd<span class="token operator">-></span>i_count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>root<span class="token punctuation">)</span>
		current<span class="token operator">-></span>root<span class="token operator">-></span>i_count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>executable<span class="token punctuation">)</span>
		current<span class="token operator">-></span>executable<span class="token operator">-></span>i_count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token function">set_tss_desc</span><span class="token punctuation">(</span>gdt<span class="token operator">+</span><span class="token punctuation">(</span>nr<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>FIRST_TSS_ENTRY<span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>tss<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">set_ldt_desc</span><span class="token punctuation">(</span>gdt<span class="token operator">+</span><span class="token punctuation">(</span>nr<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>FIRST_LDT_ENTRY<span class="token punctuation">,</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>ldt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>state <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>	<span class="token comment">/* do this last, just in case */</span>
	<span class="token keyword">return</span> last_pid<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="27、详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）"><a href="#27、详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）" class="headerlink" title="27、详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）"></a>27、详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）</h3><p>①进程中有就绪进程，且时间片没有用完。</p>
<p>正常情况下，schedule()函数首先扫描任务数组。通过比较每个就绪（TASK_RUNNING）任务的运行时间递减滴答计数counter 的值来确定当前哪个进程运行的时间最少。哪一个的值大，就表示运行时间还不长，于是就选中该进程，最后调用switch_to()执行实际的进程切换操作</p>
<p>②进程中有就绪进程，但所有就绪进程时间片都用完（c=0）</p>
<p>如果此时所有处于TASK_RUNNING 状态进程的时间片都已经用完，系统就会根据每个进程的优先权值priority，对系统中所有进程（包括正在睡眠的进程）重新计算每个任务需要运行的时间片值counter。计算的公式是：</p>
<p>counter = counter + priority/2</p>
<p>然后 schdeule()函数重新扫描任务数组中所有处于TASK_RUNNING 状态，重复上述过程，直到选择出一个进程为止。最后调用switch_to()执行实际的进程切换操作。</p>
<p>③所有进程都不是就绪的c=-1</p>
<p>此时代码中的c=-1，next=0，跳出循环后，执行switch_to(0)，切换到进程0执行，因此所有进程都不是就绪的时候进程0执行。</p>
<h3 id="28、分析panic函数的源代码，根据你学过的操作系统知识，完整、准确的判断panic函数所起的作用。假如操作系统设计为支持内核进程（始终运行在0特权级的进程），你将如何改进panic函数？"><a href="#28、分析panic函数的源代码，根据你学过的操作系统知识，完整、准确的判断panic函数所起的作用。假如操作系统设计为支持内核进程（始终运行在0特权级的进程），你将如何改进panic函数？" class="headerlink" title="28、分析panic函数的源代码，根据你学过的操作系统知识，完整、准确的判断panic函数所起的作用。假如操作系统设计为支持内核进程（始终运行在0特权级的进程），你将如何改进panic函数？"></a>28、分析panic函数的源代码，根据你学过的操作系统知识，完整、准确的判断panic函数所起的作用。假如操作系统设计为支持内核进程（始终运行在0特权级的进程），你将如何改进panic函数？</h3><p>panic函数如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">\linux0<span class="token punctuation">.</span><span class="token number">11</span>\kernel\panic<span class="token punctuation">.</span>c
<span class="token keyword">volatile</span> <span class="token keyword">void</span> <span class="token function">panic</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"Kernel panic: %s\n\r"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> task<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"In swapper task - not syncing\n\r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token function">sys_sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>①panic()函数是当系统发现无法继续运行下去的故障时将调用它，会导致程序终止，然后由系统显示错误号。如果出现错误的函数不是进程0，那么就要进行数据同步，把缓冲区中的数据尽量同步到硬盘上。遵循了Linux尽量简明的原则。</p>
<p>②改进panic函数：将死循环for(;;)改进为跳转到内核进程（始终运行在0特权级的进程），让内核继续执行。</p>
<h3 id="29、getblk函数中，申请空闲缓冲块的标准就是b-count为0，而申请到之后，为什么在wait-on-buffer-bh-后又执行if（bh-gt-b-count）来判断b-count是否为0？"><a href="#29、getblk函数中，申请空闲缓冲块的标准就是b-count为0，而申请到之后，为什么在wait-on-buffer-bh-后又执行if（bh-gt-b-count）来判断b-count是否为0？" class="headerlink" title="29、getblk函数中，申请空闲缓冲块的标准就是b_count为0，而申请到之后，为什么在wait_on_buffer(bh)后又执行if（bh-&gt;b_count）来判断b_count是否为0？"></a>29、getblk函数中，申请空闲缓冲块的标准就是b_count为0，而申请到之后，为什么在wait_on_buffer(bh)后又执行if（bh-&gt;b_count）来判断b_count是否为0？</h3><p>wait_on_buffer(bh)内包含睡眠函数，虽然此时已经找到比较合适的空闲缓冲块，但是可能在睡眠阶段该缓冲区被其他任务所占用，因此必须重新搜索，判断是否被修改，修改则写盘等待解锁。判断若被占用则重新repeat，继续执行if（bh-&gt;b_count）</p>
<h3 id="30、b-dirt已经被置为1的缓冲块，同步前能够被进程继续读、写？给出代码证据。"><a href="#30、b-dirt已经被置为1的缓冲块，同步前能够被进程继续读、写？给出代码证据。" class="headerlink" title="30、b_dirt已经被置为1的缓冲块，同步前能够被进程继续读、写？给出代码证据。"></a>30、b_dirt已经被置为1的缓冲块，同步前能够被进程继续读、写？给出代码证据。</h3><p>同步前可以被进程读写，但不能挪为它用（即关联其它物理块）。b_dirt是针对硬盘方向的，进程与缓冲块方向由b_uptodate标识。只要b_uptodate为1，缓冲块就能被进程读写。读操作不会改变缓冲块中数据的内容，写操作后，改变了缓冲区内容，需要将b_dirt置1。由于此前缓冲块中的数据已经用硬盘数据块更新了，所以后续同步过程中缓冲块没有写入新数据的部分和原来硬盘对应的部分相同，所有的数据都是进程希望同步到硬盘数据块上的，不会把垃圾数据同步到硬盘数据库上去，所以b_uptodate仍为1。<br>所以，b_dirt为1，进程仍能对缓冲区进行读写。</p>
<p>代码证据如下：</p>
<p>①读写文件均与b_dirt无关</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">\linux0<span class="token punctuation">.</span><span class="token number">11</span>\fs\file_dev<span class="token punctuation">.</span>c
<span class="token keyword">int</span> <span class="token function">file_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span> inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> filp<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">//…</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>filp<span class="token operator">-></span>f_flags <span class="token operator">&amp;</span> O_APPEND<span class="token punctuation">)</span>
		pos <span class="token operator">=</span> inode<span class="token operator">-></span>i_size<span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		pos <span class="token operator">=</span> filp<span class="token operator">-></span>f_pos<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>block <span class="token operator">=</span> <span class="token function">create_block</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span>pos<span class="token operator">/</span>BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>bh<span class="token operator">=</span><span class="token function">bread</span><span class="token punctuation">(</span>inode<span class="token operator">-></span>i_dev<span class="token punctuation">,</span>block<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token comment">//…</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">file_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">m_inode</span> <span class="token operator">*</span> inode<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span> filp<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">//…</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>left<span class="token operator">=</span>count<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nr <span class="token operator">=</span> <span class="token function">bmap</span><span class="token punctuation">(</span>inode<span class="token punctuation">,</span><span class="token punctuation">(</span>filp<span class="token operator">-></span>f_pos<span class="token punctuation">)</span><span class="token operator">/</span>BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>bh<span class="token operator">=</span><span class="token function">bread</span><span class="token punctuation">(</span>inode<span class="token operator">-></span>i_dev<span class="token punctuation">,</span>nr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span> 
	<span class="token comment">//…</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>②在获取缓冲块时，亦与b_dirt无任何关系</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">\linux0<span class="token punctuation">.</span><span class="token number">11</span>\fs\buffer<span class="token punctuation">.</span>c
<span class="token keyword">struct</span> <span class="token class-name">buffer_head</span> <span class="token operator">*</span> <span class="token function">bread</span><span class="token punctuation">(</span><span class="token keyword">int</span> dev<span class="token punctuation">,</span><span class="token keyword">int</span> block<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">buffer_head</span> <span class="token operator">*</span> bh<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>bh<span class="token operator">=</span><span class="token function">getblk</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span>block<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"bread: getblk returned NULL\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>bh<span class="token operator">-></span>b_uptodate<span class="token punctuation">)</span>
		<span class="token keyword">return</span> bh<span class="token punctuation">;</span>
	<span class="token function">ll_rw_block</span><span class="token punctuation">(</span>READ<span class="token punctuation">,</span>bh<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">wait_on_buffer</span><span class="token punctuation">(</span>bh<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>bh<span class="token operator">-></span>b_uptodate<span class="token punctuation">)</span>
		<span class="token keyword">return</span> bh<span class="token punctuation">;</span>
	<span class="token function">brelse</span><span class="token punctuation">(</span>bh<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">\linux0<span class="token punctuation">.</span><span class="token number">11</span>\fs\buffer<span class="token punctuation">.</span>c
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">BADNESS</span><span class="token expression"><span class="token punctuation">(</span>bh<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>bh<span class="token punctuation">)</span><span class="token operator">-></span>b_dirt<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>bh<span class="token punctuation">)</span><span class="token operator">-></span>b_lock<span class="token punctuation">)</span></span></span>
<span class="token keyword">struct</span> <span class="token class-name">buffer_head</span> <span class="token operator">*</span> <span class="token function">getblk</span><span class="token punctuation">(</span><span class="token keyword">int</span> dev<span class="token punctuation">,</span><span class="token keyword">int</span> block<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">buffer_head</span> <span class="token operator">*</span> tmp<span class="token punctuation">,</span> <span class="token operator">*</span> bh<span class="token punctuation">;</span>

repeat<span class="token operator">:</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>bh <span class="token operator">=</span> <span class="token function">get_hash_table</span><span class="token punctuation">(</span>dev<span class="token punctuation">,</span>block<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> bh<span class="token punctuation">;</span>
	<span class="token comment">//…</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="31、wait-on-buffer函数中为什么不用if（）而是用while（）？"><a href="#31、wait-on-buffer函数中为什么不用if（）而是用while（）？" class="headerlink" title="31、wait_on_buffer函数中为什么不用if（）而是用while（）？"></a>31、wait_on_buffer函数中为什么不用if（）而是用while（）？</h3><p>答案1</p>
<p>被调度回来 b_lock 可能还没清零；<br>有可能被其他进程加了 b_lock。<br>答案2</p>
<p>因为可能存在一种情况是，很多进程都在等待一个缓冲块。在缓冲块同步完毕，唤醒各等待进程到轮转到某一进程的过程中，很有可能此时的缓冲块又被其它进程所占用，并被加上了锁。此时如果用if()，则此进程会从之前被挂起的地方继续执行，不会再判断是否缓冲块已被占用而直接使用，就会出现错误；而如果用while()，则此进程会再次确认缓冲块是否已被占用，在确认未被占用后，才会使用，这样就不会发生之前那样的错误</p>
<h3 id="32、分析ll-rw-block-READ-bh-读硬盘块数据到缓冲区的整个流程（包括借助中断形成的类递归），叙述这些代码实现的功能。"><a href="#32、分析ll-rw-block-READ-bh-读硬盘块数据到缓冲区的整个流程（包括借助中断形成的类递归），叙述这些代码实现的功能。" class="headerlink" title="32、分析ll_rw_block(READ,bh)读硬盘块数据到缓冲区的整个流程（包括借助中断形成的类递归），叙述这些代码实现的功能。"></a>32、分析ll_rw_block(READ,bh)读硬盘块数据到缓冲区的整个流程（包括借助中断形成的类递归），叙述这些代码实现的功能。</h3><p><img src="/posts/22763.htm/image-20231227142129411.png" alt></p>
<h3 id="33、分析包括安装根文件系统、安装文件系统、打开文件、读文件在内的文件操作。"><a href="#33、分析包括安装根文件系统、安装文件系统、打开文件、读文件在内的文件操作。" class="headerlink" title="33、分析包括安装根文件系统、安装文件系统、打开文件、读文件在内的文件操作。"></a>33、分析包括安装根文件系统、安装文件系统、打开文件、读文件在内的文件操作。</h3><p><img src="/posts/22763.htm/image-20231227142344859.png" alt></p>
<h3 id="34、在创建进程、从硬盘加载程序、执行这个程序的过程中，sys-fork、do-execve、do-no-page分别起了什么作用？"><a href="#34、在创建进程、从硬盘加载程序、执行这个程序的过程中，sys-fork、do-execve、do-no-page分别起了什么作用？" class="headerlink" title="34、在创建进程、从硬盘加载程序、执行这个程序的过程中，sys_fork、do_execve、do_no_page分别起了什么作用？"></a>34、在创建进程、从硬盘加载程序、执行这个程序的过程中，sys_fork、do_execve、do_no_page分别起了什么作用？</h3><p>sys_fork 用于进程的创建，do_execve 用于加载并执行新的程序，而 do_no_page 用于处理程序执行过程中的缺页异常，确保所需的内存页面被正确加载。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuichi.top">Yuichi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuichi.top/posts/22763.html">https://yuichi.top/posts/22763.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yuichi.top" target="_blank">Yuichi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/15.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4847.html" title="国科大-高性能计算编程-作业一"><img class="cover" src="/img/cover/19.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">国科大-高性能计算编程-作业一</div></div></a></div><div class="next-post pull-right"><a href="/posts/46552.html" title="FISCO BCOS区块链系统新增节点时无法同步数据的原因及解决方法"><img class="cover" src="/img/cover/22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">FISCO BCOS区块链系统新增节点时无法同步数据的原因及解决方法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Yuichi</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yuichi1001"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://blog.csdn.net/Qudoudou2020" target="_blank" title="CSDN"><i class="fas fa-solid fa-c" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:913637919@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">把主题更换成butterly啦！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%90%AF%E5%8A%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E6%98%AFBIOS%E4%BB%A3%E7%A0%81%E8%80%8C%E4%B8%8D%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%87%AA%E8%BA%AB%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1.为什么开始启动计算机的时候，执行的是BIOS代码而不是操作系统自身的代码？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88BIOS%E5%8F%AA%E5%8A%A0%E8%BD%BD%E4%BA%86%E4%B8%80%E4%B8%AA%E6%89%87%E5%8C%BA%EF%BC%8C%E5%90%8E%E7%BB%AD%E6%89%87%E5%8C%BA%E5%8D%B4%E6%98%AF%E7%94%B1bootsect%E4%BB%A3%E7%A0%81%E5%8A%A0%E8%BD%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88BIOS%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E6%8A%8A%E6%89%80%E6%9C%89%E9%9C%80%E8%A6%81%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%89%87%E5%8C%BA%E9%83%BD%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2.为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有直接把所有需要加载的扇区都加载？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88BIOS%E6%8A%8Abootsect%E5%8A%A0%E8%BD%BD%E5%88%B00x07c00%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF0x00000%EF%BC%9F%E5%8A%A0%E8%BD%BD%E5%90%8E%E5%8F%88%E9%A9%AC%E4%B8%8A%E6%8C%AA%E5%88%B00x90000%E5%A4%84%EF%BC%8C%E6%98%AF%E4%BD%95%E9%81%93%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%B8%80%E6%AC%A1%E5%8A%A0%E8%BD%BD%E5%88%B0%E4%BD%8D%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">3.为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-bootsect%E3%80%81setup%E3%80%81head%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E8%A1%94%E6%8E%A5%E7%9A%84%EF%BC%9F%E7%BB%99%E5%87%BA%E4%BB%A3%E7%A0%81%E8%AF%81%E6%8D%AE%E3%80%82"><span class="toc-number">4.</span> <span class="toc-text">4.bootsect、setup、head程序之间是怎么衔接的？给出代码证据。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-setup%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%80%E5%90%8E%E6%98%AFjmpi-0-8-%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B8%AA8%E4%B8%8D%E8%83%BD%E7%AE%80%E5%8D%95%E7%9A%84%E5%BD%93%E4%BD%9C%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%978%E7%9C%8B%E5%BE%85%EF%BC%8C%E7%A9%B6%E7%AB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%86%85%E6%B6%B5%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5.setup程序的最后是jmpi 0,8 ，为什么这个8不能简单的当作阿拉伯数字8看待，究竟有什么内涵？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%9C%A8%E2%80%9C%E4%BF%9D%E6%8A%A4%E2%80%9D%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E7%9A%84%E2%80%9C%E4%BF%9D%E6%8A%A4%E2%80%9D%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F%E7%89%B9%E6%9D%83%E7%BA%A7%E7%9A%84%E7%9B%AE%E7%9A%84%E5%92%8C%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%88%86%E9%A1%B5%E6%9C%89%E2%80%9C%E4%BF%9D%E6%8A%A4%E2%80%9D%E4%BD%9C%E7%94%A8%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%89%B9%E6%9D%83%E7%BA%A7%E6%98%AF%E5%9F%BA%E4%BA%8E%E6%AE%B5%E7%9A%84%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6.保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？为什么特权级是基于段的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%9C%A8setup%E7%A8%8B%E5%BA%8F%E9%87%8C%E6%9B%BE%E7%BB%8F%E8%AE%BE%E7%BD%AE%E8%BF%87gdt%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8head%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B0%86%E5%85%B6%E5%BA%9F%E5%BC%83%EF%BC%8C%E5%8F%88%E9%87%8D%E6%96%B0%E8%AE%BE%E7%BD%AE%E4%BA%86%E4%B8%80%E4%B8%AA%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E7%BD%AE%E4%B8%A4%E6%AC%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E6%AC%A1%E6%90%9E%E5%A5%BD%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">7.在setup程序里曾经设置过gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么设置两次，而不是一次搞好？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%86%85%E6%A0%B8%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F%E7%94%BB%E5%87%BA%E4%BB%8E0x000000%E5%BC%80%E5%A7%8B%E7%9A%847%E4%B8%AA%E9%A1%B5%EF%BC%88%E5%8C%85%E6%8B%AC%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8%E3%80%81%E9%A1%B5%E8%A1%A8%E6%89%80%E5%9C%A8%E9%A1%B5%EF%BC%89%E7%9A%84%E6%8C%82%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%9B%BE%EF%BC%8C%E5%B0%B1%E6%98%AF%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8%E7%9A%84%E5%89%8D%E5%9B%9B%E4%B8%AA%E9%A1%B5%E7%9B%AE%E5%BD%95%E9%A1%B9%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%AA%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%89%8D7%E4%B8%AA%E9%A1%B5%E8%A1%A8%E9%A1%B9%E6%8C%87%E5%90%91%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE%EF%BC%9F%E7%BB%99%E5%87%BA%E4%BB%A3%E7%A0%81%E8%AF%81%E6%8D%AE%E3%80%82"><span class="toc-number">8.</span> <span class="toc-text">8.内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%A0%B9%E6%8D%AE%E5%86%85%E6%A0%B8%E5%88%86%E9%A1%B5%E4%B8%BA%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E6%81%92%E7%AD%89%E6%98%A0%E5%B0%84%E7%9A%84%E8%A6%81%E6%B1%82%EF%BC%8C%E6%8E%A8%E5%AF%BC%E5%87%BA%E5%9B%9B%E4%B8%AA%E9%A1%B5%E8%A1%A8%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%AC%E5%BC%8F%EF%BC%8C%E5%86%99%E5%87%BA%E9%A1%B5%E8%A1%A8%E7%9A%84%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%A0%81%E3%80%82"><span class="toc-number">9.</span> <span class="toc-text">9.根据内核分页为线性地址恒等映射的要求，推导出四个页表的映射公式，写出页表的设置代码。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8call%EF%BC%8C%E8%80%8C%E6%98%AF%E7%94%A8ret%E2%80%9C%E8%B0%83%E7%94%A8%E2%80%9Dmain%E5%87%BD%E6%95%B0%EF%BC%9F%E7%94%BB%E5%87%BA%E8%B0%83%E7%94%A8%E8%B7%AF%E7%BA%BF%E5%9B%BE%EF%BC%8C%E7%BB%99%E5%87%BA%E4%BB%A3%E7%A0%81%E8%AF%81%E6%8D%AE%E3%80%82"><span class="toc-number">10.</span> <span class="toc-text">10.为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E8%AE%A1%E7%AE%97%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E6%AE%B5%E3%80%81%E6%95%B0%E6%8D%AE%E6%AE%B5%E7%9A%84%E6%AE%B5%E5%9F%BA%E5%9D%80%E3%80%81%E6%AE%B5%E9%99%90%E9%95%BF%E3%80%81%E7%89%B9%E6%9D%83%E7%BA%A7%E3%80%82"><span class="toc-number">11.</span> <span class="toc-text">11、计算内核代码段、数据段的段基址、段限长、特权级。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E8%AE%A1%E7%AE%97%E8%BF%9B%E7%A8%8B0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%AE%B5%E3%80%81%E6%95%B0%E6%8D%AE%E6%AE%B5%E7%9A%84%E6%AE%B5%E5%9F%BA%E5%9D%80%E3%80%81%E6%AE%B5%E9%99%90%E9%95%BF%E3%80%81%E7%89%B9%E6%9D%83%E7%BA%A7%E3%80%82"><span class="toc-number">12.</span> <span class="toc-text">12、计算进程0的代码段、数据段的段基址、段限长、特权级。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81fork%E8%BF%9B%E7%A8%8B1%E4%B9%8B%E5%89%8D%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88%E8%B0%83%E7%94%A8move-to-user-mode-%EF%BC%9F%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%EF%BC%9F%E8%A7%A3%E9%87%8A%E5%85%B6%E4%B8%AD%E7%9A%84%E9%81%93%E7%90%86%E3%80%82"><span class="toc-number">13.</span> <span class="toc-text">13、fork进程1之前，为什么先调用move_to_user_mode()？用的是什么方法？解释其中的道理。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E6%A0%B9%E6%8D%AE%E4%BB%80%E4%B9%88%E5%88%A4%E5%AE%9Amove-to-user-mode-%E4%B8%ADiret%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%BA%E8%BF%9B%E7%A8%8B0%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82"><span class="toc-number">14.</span> <span class="toc-text">14、根据什么判定move_to_user_mode()中iret之后的代码为进程0的代码。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E8%BF%9B%E7%A8%8B0%E7%9A%84task-struct%E5%9C%A8%E5%93%AA%EF%BC%9F%E5%85%B7%E4%BD%93%E5%86%85%E5%AE%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%BB%99%E5%87%BA%E4%BB%A3%E7%A0%81%E8%AF%81%E6%8D%AE%E3%80%82"><span class="toc-number">15.</span> <span class="toc-text">15、进程0的task_struct在哪？具体内容是什么？给出代码证据。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E5%9C%A8system-h%E9%87%8C%EF%BC%8C%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E3%80%82%E8%AF%BB%E6%87%82%E4%BB%A3%E7%A0%81%E3%80%82%E8%BF%99%E9%87%8C%E4%B8%AD%E6%96%AD%E9%97%A8%E3%80%81%E9%99%B7%E9%98%B1%E9%97%A8%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%83%BD%E6%98%AF%E9%80%9A%E8%BF%87-set-gate%E8%AE%BE%E7%BD%AE%E7%9A%84%EF%BC%8C%E7%94%A8%E7%9A%84%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%E5%B5%8C%E5%85%A5%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%AF%94%E8%BE%83%E6%98%8E%E6%98%BE%E7%9A%84%E5%B7%AE%E5%88%AB%E6%98%AFdpl%E4%B8%80%E4%B8%AA%E6%98%AF3%EF%BC%8C%E5%8F%A6%E5%A4%96%E4%B8%A4%E4%B8%AA%E6%98%AF0%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%B4%E6%98%8E%E7%90%86%E7%94%B1%E3%80%82"><span class="toc-number">16.</span> <span class="toc-text">16、在system.h里，有以下代码。读懂代码。这里中断门、陷阱门、系统调用都是通过_set_gate设置的，用的是同一个嵌入汇编代码，比较明显的差别是dpl一个是3，另外两个是0，这是为什么？说明理由。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E5%88%86%E6%9E%90get-free-page-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%99%E8%BF%B0%E5%9C%A8%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B2%E9%A1%B5%E7%9A%84%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E3%80%82"><span class="toc-number">17.</span> <span class="toc-text">17、分析get_free_page()函数的代码，叙述在主内存中获取一个空闲页的技术路线。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81copy-process%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%80%E5%90%8E%E4%BA%94%E9%A1%B9%E6%98%AF%EF%BC%9Along-eip-long-cs-long-eflags-long-esp-long-ss%E3%80%82%E6%9F%A5%E7%9C%8B%E6%A0%88%E7%BB%93%E6%9E%84%E7%A1%AE%E5%AE%9E%E6%9C%89%E8%BF%99%E4%BA%94%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%8C%E5%A5%87%E6%80%AA%E7%9A%84%E6%98%AF%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0%E7%9A%84%E5%8E%8B%E6%A0%88%E4%BB%A3%E7%A0%81%E9%83%BD%E8%83%BD%E6%89%BE%E5%BE%97%E5%88%B0%EF%BC%8C%E7%A1%AE%E6%89%BE%E4%B8%8D%E5%88%B0%E8%BF%99%E4%BA%94%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%8E%8B%E6%A0%88%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%B9%9F%E6%9F%A5%E4%B8%8D%E5%88%B0%EF%BC%8C%E8%AF%B7%E8%A7%A3%E9%87%8A%E5%8E%9F%E5%9B%A0%E3%80%82%E8%AF%A6%E7%BB%86%E8%AE%BA%E8%AF%81%E5%85%B6%E4%BB%96%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E5%85%A5%E7%9A%84%E3%80%82"><span class="toc-number">18.</span> <span class="toc-text">18、copy_process函数的参数最后五项是：long eip,long cs,long eflags,long esp,long ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。详细论证其他所有参数是如何传入的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E3%80%82"><span class="toc-number">19.</span> <span class="toc-text">19、详细分析Linux操作系统如何设置保护模式的中断机制。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E5%88%86%E6%9E%90Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E5%89%A5%E5%A4%BA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E6%A0%B8%E5%8F%8A%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%83%BD%E5%8A%9B%E3%80%82"><span class="toc-number">20.</span> <span class="toc-text">20、分析Linux操作系统如何剥夺用户进程访问内核及其他进程的能力。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81-system-call%E4%B8%AD%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%88%86%E6%9E%90%E5%90%8E%E9%9D%A2%E8%BF%99%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89%E3%80%82"><span class="toc-number">21.</span> <span class="toc-text">21、_system_call中有以下代码，分析后面这两行代码的意义。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E5%88%86%E6%9E%90copy-page-tables%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%99%E8%BF%B0%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E4%B8%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%A4%8D%E5%88%B6%E9%A1%B5%E8%A1%A8%E3%80%82"><span class="toc-number">22.</span> <span class="toc-text">22、分析copy_page_tables（）函数的代码，叙述父进程如何为子进程复制页表。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E8%BF%9B%E7%A8%8B0%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B1%E6%97%B6%EF%BC%8C%E4%B8%BA%E8%BF%9B%E7%A8%8B1%E5%BB%BA%E7%AB%8B%E4%BA%86task-struct%E5%8F%8A%E5%86%85%E6%A0%B8%E6%A0%88%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B5%E8%A1%A8%EF%BC%8C%E5%88%86%E5%88%AB%E4%BD%8D%E4%BA%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%A4%E4%B8%AA%E9%A1%B5%E3%80%82%E8%AF%B7%E9%97%AE%EF%BC%8C%E8%BF%99%E4%B8%A4%E4%B8%AA%E9%A1%B5%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E7%A9%B6%E7%AB%9F%E5%8D%A0%E7%94%A8%E7%9A%84%E6%98%AF%E8%B0%81%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%86%85%E6%A0%B8%E3%80%81%E8%BF%9B%E7%A8%8B0%E3%80%81%E8%BF%9B%E7%A8%8B1%E3%80%81%E8%BF%98%E6%98%AF%E6%B2%A1%E6%9C%89%E5%8D%A0%E7%94%A8%E4%BB%BB%E4%BD%95%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%9F%E8%AF%B4%E6%98%8E%E7%90%86%E7%94%B1%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%9B%BE%E7%A4%BA%EF%BC%89%E5%B9%B6%E7%BB%99%E5%87%BA%E4%BB%A3%E7%A0%81%E8%AF%81%E6%8D%AE%E3%80%82"><span class="toc-number">23.</span> <span class="toc-text">23、进程0创建进程1时，为进程1建立了task_struct及内核栈，第一个页表，分别位于物理内存两个页。请问，这两个页的位置，究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81%E5%81%87%E8%AE%BE%EF%BC%9A%E7%BB%8F%E8%BF%87%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E8%BF%90%E8%A1%8C%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B7%B2%E7%BB%8F%E6%9C%895%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%9C%A8%E8%BF%90%E8%A1%8C%EF%BC%8C%E4%B8%94%E5%86%85%E6%A0%B8%E4%B8%BA%E8%BF%9B%E7%A8%8B4%E3%80%81%E8%BF%9B%E7%A8%8B5%E5%88%86%E5%88%AB%E5%88%9B%E5%BB%BA%E4%BA%86%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B5%E8%A1%A8%EF%BC%8C%E8%BF%99%E4%B8%A4%E4%B8%AA%E9%A1%B5%E8%A1%A8%E5%9C%A8%E8%B0%81%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%9F%E7%94%A8%E5%9B%BE%E8%A1%A8%E7%A4%BA%E8%BF%99%E4%B8%A4%E4%B8%AA%E9%A1%B5%E8%A1%A8%E5%9C%A8%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E3%80%82"><span class="toc-number">24.</span> <span class="toc-text">24、假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E6%9C%89%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E2%80%9Dljmp-0-n-t%E2%80%9D-%E5%BE%88%E5%A5%87%E6%80%AA%EF%BC%8C%E6%8C%89%E7%90%86%E8%AF%B4jmp%E6%8C%87%E4%BB%A4%E8%B7%B3%E8%BD%AC%E5%88%B0%E5%BE%97%E4%BD%8D%E7%BD%AE%E5%BA%94%E8%AF%A5%E6%98%AF%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%8F%AF%E6%98%AF%E8%BF%99%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%8D%B4%E8%B7%B3%E5%88%B0%E4%BA%86%E2%80%9Dm%E2%80%9D-amp-tmp-a-%EF%BC%8C%E8%BF%99%E6%98%8E%E6%98%8E%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%9B%B4%E5%A5%87%E6%80%AA%E7%9A%84%EF%BC%8C%E8%BF%99%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%AB%9F%E7%84%B6%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E3%80%82%E8%AF%B7%E8%AE%BA%E8%BF%B0%E5%85%B6%E4%B8%AD%E7%9A%84%E9%81%93%E7%90%86%E3%80%82"><span class="toc-number">25.</span> <span class="toc-text">25、有以下代码，代码中的”ljmp %0\n\t” 很奇怪，按理说jmp指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了”m” (*&amp;__tmp.a)，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81%E8%BF%9B%E7%A8%8B0%E5%BC%80%E5%A7%8B%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B1%EF%BC%8C%E8%B0%83%E7%94%A8fork%EF%BC%88%EF%BC%89%EF%BC%8C%E8%B7%9F%E8%B8%AA%E4%BB%A3%E7%A0%81%E6%97%B6%E6%88%91%E4%BB%AC%E5%8F%91%E7%8E%B0%EF%BC%8Cfork%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E4%BA%86%E4%B8%A4%E6%AC%A1%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%EF%BC%8C%E6%89%A7%E8%A1%8Cfork%E4%BB%A3%E7%A0%81%E5%90%8E%EF%BC%8C%E8%B7%B3%E8%BF%87init%EF%BC%88%EF%BC%89%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E4%BA%86for-pause-%EF%BC%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%A7%E8%A1%8Cfork%E4%BB%A3%E7%A0%81%E5%90%8E%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%BA%86init%EF%BC%88%EF%BC%89%E3%80%82%E5%A5%87%E6%80%AA%E7%9A%84%E6%98%AF%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%B9%B6%E6%B2%A1%E6%9C%89%E7%9C%8B%E5%88%B0%E5%90%91%E8%BD%AC%E5%90%91fork%E7%9A%84goto%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B9%9F%E6%B2%A1%E6%9C%89%E7%9C%8B%E5%88%B0%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%EF%BC%8C%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%AF%BC%E8%87%B4fork%E5%8F%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%EF%BC%9F%E8%AF%B7%E8%AF%B4%E6%98%8E%E7%90%86%E7%94%B1%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%9B%BE%E7%A4%BA%EF%BC%89%EF%BC%8C%E5%B9%B6%E7%BB%99%E5%87%BA%E4%BB%A3%E7%A0%81%E8%AF%81%E6%8D%AE%E3%80%82"><span class="toc-number">26.</span> <span class="toc-text">26、进程0开始创建进程1，调用fork（），跟踪代码时我们发现，fork代码执行了两次，第一次，执行fork代码后，跳过init（）直接执行了for(;;) pause()，第二次执行fork代码后，执行了init（）。奇怪的是，我们在代码中并没有看到向转向fork的goto语句，也没有看到循环语句，是什么原因导致fork反复执行？请说明理由（可以图示），并给出代码证据。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E3%80%82%E8%80%83%E8%99%91%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%EF%BC%88signal%E3%80%81alarm%E9%99%A4%E5%A4%96%EF%BC%89"><span class="toc-number">27.</span> <span class="toc-text">27、详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81%E5%88%86%E6%9E%90panic%E5%87%BD%E6%95%B0%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%A0%B9%E6%8D%AE%E4%BD%A0%E5%AD%A6%E8%BF%87%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%EF%BC%8C%E5%AE%8C%E6%95%B4%E3%80%81%E5%87%86%E7%A1%AE%E7%9A%84%E5%88%A4%E6%96%ADpanic%E5%87%BD%E6%95%B0%E6%89%80%E8%B5%B7%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82%E5%81%87%E5%A6%82%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%BA%E6%94%AF%E6%8C%81%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%EF%BC%88%E5%A7%8B%E7%BB%88%E8%BF%90%E8%A1%8C%E5%9C%A80%E7%89%B9%E6%9D%83%E7%BA%A7%E7%9A%84%E8%BF%9B%E7%A8%8B%EF%BC%89%EF%BC%8C%E4%BD%A0%E5%B0%86%E5%A6%82%E4%BD%95%E6%94%B9%E8%BF%9Bpanic%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">28、分析panic函数的源代码，根据你学过的操作系统知识，完整、准确的判断panic函数所起的作用。假如操作系统设计为支持内核进程（始终运行在0特权级的进程），你将如何改进panic函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81getblk%E5%87%BD%E6%95%B0%E4%B8%AD%EF%BC%8C%E7%94%B3%E8%AF%B7%E7%A9%BA%E9%97%B2%E7%BC%93%E5%86%B2%E5%9D%97%E7%9A%84%E6%A0%87%E5%87%86%E5%B0%B1%E6%98%AFb-count%E4%B8%BA0%EF%BC%8C%E8%80%8C%E7%94%B3%E8%AF%B7%E5%88%B0%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8wait-on-buffer-bh-%E5%90%8E%E5%8F%88%E6%89%A7%E8%A1%8Cif%EF%BC%88bh-gt-b-count%EF%BC%89%E6%9D%A5%E5%88%A4%E6%96%ADb-count%E6%98%AF%E5%90%A6%E4%B8%BA0%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">29、getblk函数中，申请空闲缓冲块的标准就是b_count为0，而申请到之后，为什么在wait_on_buffer(bh)后又执行if（bh-&gt;b_count）来判断b_count是否为0？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81b-dirt%E5%B7%B2%E7%BB%8F%E8%A2%AB%E7%BD%AE%E4%B8%BA1%E7%9A%84%E7%BC%93%E5%86%B2%E5%9D%97%EF%BC%8C%E5%90%8C%E6%AD%A5%E5%89%8D%E8%83%BD%E5%A4%9F%E8%A2%AB%E8%BF%9B%E7%A8%8B%E7%BB%A7%E7%BB%AD%E8%AF%BB%E3%80%81%E5%86%99%EF%BC%9F%E7%BB%99%E5%87%BA%E4%BB%A3%E7%A0%81%E8%AF%81%E6%8D%AE%E3%80%82"><span class="toc-number">30.</span> <span class="toc-text">30、b_dirt已经被置为1的缓冲块，同步前能够被进程继续读、写？给出代码证据。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81wait-on-buffer%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8if%EF%BC%88%EF%BC%89%E8%80%8C%E6%98%AF%E7%94%A8while%EF%BC%88%EF%BC%89%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">31、wait_on_buffer函数中为什么不用if（）而是用while（）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81%E5%88%86%E6%9E%90ll-rw-block-READ-bh-%E8%AF%BB%E7%A1%AC%E7%9B%98%E5%9D%97%E6%95%B0%E6%8D%AE%E5%88%B0%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B%EF%BC%88%E5%8C%85%E6%8B%AC%E5%80%9F%E5%8A%A9%E4%B8%AD%E6%96%AD%E5%BD%A2%E6%88%90%E7%9A%84%E7%B1%BB%E9%80%92%E5%BD%92%EF%BC%89%EF%BC%8C%E5%8F%99%E8%BF%B0%E8%BF%99%E4%BA%9B%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E3%80%82"><span class="toc-number">32.</span> <span class="toc-text">32、分析ll_rw_block(READ,bh)读硬盘块数据到缓冲区的整个流程（包括借助中断形成的类递归），叙述这些代码实现的功能。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81%E5%88%86%E6%9E%90%E5%8C%85%E6%8B%AC%E5%AE%89%E8%A3%85%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E3%80%81%E8%AF%BB%E6%96%87%E4%BB%B6%E5%9C%A8%E5%86%85%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">33.</span> <span class="toc-text">33、分析包括安装根文件系统、安装文件系统、打开文件、读文件在内的文件操作。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81%E5%9C%A8%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E3%80%81%E4%BB%8E%E7%A1%AC%E7%9B%98%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E3%80%81%E6%89%A7%E8%A1%8C%E8%BF%99%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8Csys-fork%E3%80%81do-execve%E3%80%81do-no-page%E5%88%86%E5%88%AB%E8%B5%B7%E4%BA%86%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">34、在创建进程、从硬盘加载程序、执行这个程序的过程中，sys_fork、do_execve、do_no_page分别起了什么作用？</span></a></li></ol></div></div><div class="card-widget card-calendar"><div class="card-content"><div class="item-headline"><i class="fas fa-calendar"></i><span>文章日历</span></div><div class="widget" id="calendar"></div></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/24430.html" title="国科大-高性能计算编程-作业六"><img src="/img/cover/23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="国科大-高性能计算编程-作业六"/></a><div class="content"><a class="title" href="/posts/24430.html" title="国科大-高性能计算编程-作业六">国科大-高性能计算编程-作业六</a><time datetime="2024-05-25T05:22:06.000Z" title="发表于 2024-05-25 13:22:06">2024-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/32238.html" title="国科大-高性能计算编程-作业五"><img src="/img/cover/10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="国科大-高性能计算编程-作业五"/></a><div class="content"><a class="title" href="/posts/32238.html" title="国科大-高性能计算编程-作业五">国科大-高性能计算编程-作业五</a><time datetime="2024-05-09T13:04:38.000Z" title="发表于 2024-05-09 21:04:38">2024-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/59879.html" title="国科大-高性能计算编程-作业四"><img src="/img/cover/23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="国科大-高性能计算编程-作业四"/></a><div class="content"><a class="title" href="/posts/59879.html" title="国科大-高性能计算编程-作业四">国科大-高性能计算编程-作业四</a><time datetime="2024-04-21T11:16:33.000Z" title="发表于 2024-04-21 19:16:33">2024-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5167.html" title="国科大-高性能计算编程-作业三"><img src="/img/cover/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="国科大-高性能计算编程-作业三"/></a><div class="content"><a class="title" href="/posts/5167.html" title="国科大-高性能计算编程-作业三">国科大-高性能计算编程-作业三</a><time datetime="2024-04-06T11:28:31.000Z" title="发表于 2024-04-06 19:28:31">2024-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/30702.html" title="国科大-高性能计算编程-作业二"><img src="/img/cover/19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="国科大-高性能计算编程-作业二"/></a><div class="content"><a class="title" href="/posts/30702.html" title="国科大-高性能计算编程-作业二">国科大-高性能计算编程-作业二</a><time datetime="2024-03-22T04:53:48.000Z" title="发表于 2024-03-22 12:53:48">2024-03-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Yuichi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="/js/jquery.js"></script><script src="/js/foot.js"></script><script src="/js/nav.js"></script><script src="http://cdn.bootcss.com/pace/1.0.2/pace.min.js" async></script><script src="/js/languages.js"></script><script src="/js/calendar.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script src="/js/sun_moon.js" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>